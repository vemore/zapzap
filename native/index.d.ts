/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 * Get card points for zapzap calculation
 * Jokers (52-53) = 0 points
 */
export declare function getCardPoints(cardId: number): number
/** Get card rank (0-12), returns 255 for jokers */
export declare function getRank(cardId: number): number
/** Get card suit (0-3), returns 255 for jokers */
export declare function getSuit(cardId: number): number
/** Check if card is a joker */
export declare function isJoker(cardId: number): boolean
/**
 * Calculate total hand value (for zapzap eligibility)
 * Jokers count as 0 points
 */
export declare function calculateHandValue(hand: Array<number>): number
/**
 * Calculate hand score for end of round
 * Jokers = 0 if lowest hand, 25 otherwise
 */
export declare function calculateHandScore(hand: Array<number>, isLowest: boolean): number
/** Check if player can call ZapZap (hand value <= 5) */
export declare function canCallZapzap(hand: Array<number>): boolean
/** Check if cards form a valid same-rank combination */
export declare function isValidSameRank(cards: Array<number>): boolean
/** Check if cards form a valid sequence */
export declare function isValidSequence(cards: Array<number>): boolean
/** Check if a play is valid */
export declare function isValidPlay(cards: Array<number>): boolean
/** Find all valid same-rank plays in hand */
export declare function findSameRankPlays(hand: Array<number>): Array<Array<number>>
/** Find all valid sequence plays in hand */
export declare function findSequencePlays(hand: Array<number>): Array<Array<number>>
/** Find all valid plays in hand */
export declare function findAllValidPlays(hand: Array<number>): Array<Array<number>>
/** Find the play that removes the most points from hand */
export declare function findMaxPointPlay(hand: Array<number>): Array<number> | null
/** Run benchmark: find all valid plays N times */
export declare function benchmarkFindAllValidPlays(hand: Array<number>, iterations: number): number
/** Game result from simulation */
export interface NativeGameResult {
  winner: number
  totalRounds: number
  finalScores: Array<number>
  wasGoldenScore: boolean
  playerCount: number
}
/**
 * Run a single game with specified strategies
 * Strategy types: "random", "hard"
 */
export declare function runGame(strategyTypes: Array<string>, seed?: number | undefined | null): NativeGameResult
/** Run multiple games and return statistics */
export interface BatchGameStats {
  gamesPlayed: number
  wins: Array<number>
  avgRounds: number
  totalTimeMs: number
  gamesPerSecond: number
}
/** Run multiple games in batch for performance testing */
export declare function runGamesBatch(strategyTypes: Array<string>, gameCount: number, baseSeed?: number | undefined | null): BatchGameStats
/** Benchmark game simulation performance */
export declare function benchmarkSimulation(playerCount: number, gameCount: number): number
/** Get feature dimension (45) */
export declare function getFeatureDimension(): number
/**
 * Extract features from a game state for ML
 * Returns 45-dimensional feature vector
 */
export declare function extractFeatures(hand: Array<number>, playerIndex: number, scores: Array<number>, opponentHandSizes: Array<number>, roundNumber: number, deckSize: number, lastCardsPlayed: Array<number>, isGoldenScore: boolean, eliminatedPlayers: Array<number>): Array<number>
/** Extract features for hand size decision (before cards are dealt) */
export declare function extractHandSizeFeatures(activePlayerCount: number, isGoldenScore: boolean, myScore: number): Array<number>
/** Benchmark feature extraction */
export declare function benchmarkFeatureExtraction(iterations: number): number
/** Initialize the DQN with random weights */
export declare function dqnInit(seed?: number | undefined | null): boolean
/**
 * Get Q-values for a decision type
 * decision_type: "handSize", "zapzap", "playType", "drawSource"
 */
export declare function dqnPredict(features: Array<number>, decisionType: string): Array<number>
/** Select action using epsilon-greedy policy */
export declare function dqnSelectAction(features: Array<number>, decisionType: string, epsilon: number): number
/** Get greedy action (best Q-value) */
export declare function dqnGreedyAction(features: Array<number>, decisionType: string): number
/** Benchmark DQN inference */
export declare function benchmarkDqnInference(iterations: number): number
