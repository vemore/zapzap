const { ranks, suits, Card } = require('cards');
const logger = require('./logger');
const { InvalidCardError, InvalidPlayError, ErrorCodes } = require('./gameError');

function str_cards(hand) {
    if (!Array.isArray(hand)) {
        throw new InvalidPlayError('Invalid hand format', {
            code: ErrorCodes.INVALID_PLAYER_HAND,
            received: typeof hand,
            expected: 'array of cards'
        });
    }

    let str_hand = "";
    hand.forEach((card, index) => {
        if (!card || !card.rank || !card.suit) {
            throw new InvalidCardError('Invalid card in hand', {
                code: ErrorCodes.INVALID_CARD_SUIT,
                index,
                card
            });
        }
        str_hand += card.rank.shortName + (card.suit.unicode != null ? card.suit.unicode : "") + "\t";
    });
    return str_hand;
}

function print_players_hands(players) {
    if (!Array.isArray(players)) {
        throw new InvalidPlayError('Invalid players array', {
            code: ErrorCodes.INVALID_PLAYER_COUNT,
            received: typeof players,
            expected: 'array of players'
        });
    }

    players.forEach((player, index) => {
        if (!player || !player.name || !Array.isArray(player.hand)) {
            throw new InvalidPlayError('Invalid player object', {
                code: ErrorCodes.INVALID_PLAYER_COUNT,
                index,
                player
            });
        }
        logger.debug('Player hand', {
            player: player.name,
            hand: str_cards(player.hand)
        });
    });
}

function get_card_id(card, deck) {
    try {
        if (!card || !card.rank || !card.suit || !card.rank.shortName) {
            logger.error('Invalid card object', {
                code: ErrorCodes.INVALID_CARD_RANK
            });
            return -1;
        }

        // Handle jokers specially
        if (card.rank.shortName === 'Joker') {
            if (!deck || !deck.findCards) {
                logger.error('No jokers in deck', {
                    code: ErrorCodes.INVALID_CARD_JOKER,
                    card
                });
                return -1;
            }
            const jokers = deck.findCards(c => c.rank.shortName === 'Joker');
            if (!jokers || jokers.length === 0) {
                logger.error('No jokers in deck', {
                    code: ErrorCodes.INVALID_CARD_JOKER,
                    card
                });
                return -1;
            }
            // Return either 52 or 53 depending on position in jokers array
            const jokerIndex = jokers.findIndex(j => j === card);
            if (jokerIndex === -1) {
                logger.error('Unknown joker', {
                    code: ErrorCodes.INVALID_CARD_JOKER,
                    card,
                    availableJokers: jokers.length
                });
                return -1;
            }
            return 52 + jokerIndex;
        }

        // Get rank index (0-12)
        const rankNames = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

function json_hand(hand, deck) {
    if (!Array.isArray(hand)) {
        throw new InvalidPlayError('Invalid hand format', {
            code: ErrorCodes.INVALID_PLAYER_HAND,
            received: typeof hand,
            expected: 'array of cards'
        });
    }

    const json_ret = [];
    for (let i = 0; i < hand.length; i++) {
        const card = hand[i];
        if (!card || !card.rank || !card.suit || !card.rank.shortName) {
            throw new InvalidCardError('Invalid card in hand', {
                code: ErrorCodes.INVALID_CARD_SUIT,
                index: i,
                card
            });
        }

        const id = get_card_id(card, deck);
        if (id === -1) {
            // Special case for jokers - verify deck can handle them
            if (card.rank.shortName === 'Joker' && (!deck || !deck.findCards)) {
                throw new InvalidCardError('Cannot resolve joker without a valid deck', {
                    code: ErrorCodes.INVALID_CARD_JOKER,
                    index: i,
                    card
                });
            }
            throw new InvalidCardError('Invalid card in hand', {
                code: ErrorCodes.INVALID_CARD_SUIT,
                index: i,
                card
            });
        }
        json_ret.push(id);
    }
    return json_ret;
}

function get_card_from_id(card_id, deck) {
    if (!deck) {
        logger.error('No deck provided', {
            code: ErrorCodes.INVALID_CARD_JOKER,
            card_id
        });
        return undefined;
    }

    if (typeof card_id !== 'number' || isNaN(card_id) || card_id < -1) {
        logger.error('Invalid card ID format', {
            code: ErrorCodes.INVALID_CARD_SUIT,
            card_id,
            expected: 'number >= -1'
        });
        return undefined;
    }

    if (card_id === -1) {
        return undefined;
    }

    if (card_id >= 52) {
        if (card_id > 54) {
            logger.error('Card ID out of range', {
                code: ErrorCodes.INVALID_CARD_JOKER,
                card_id,
                maxId: 54
            });
            return undefined;
        }
        const jokers = deck.findCards((card) => card.rank.shortName === "Joker");
        if (!jokers || jokers.length === 0) {
            logger.error('No jokers in deck', {
                code: ErrorCodes.INVALID_CARD_JOKER,
                card_id
            });
            return undefined;
        }
        return jokers[card_id - 52];
    }

    const suitIndex = Math.trunc(card_id/13);
    let suit;
    switch (suitIndex) {
        case 0: suit = suits.spades; break;
        case 1: suit = suits.hearts; break;
        case 2: suit = suits.clubs; break;
        case 3: suit = suits.diamonds; break;
        default:
            logger.error('Invalid card ID suit', {
                code: ErrorCodes.INVALID_CARD_SUIT,
                card_id,
                suitIndex,
                validRange: '0-3'
            });
            return undefined;
    }

    const rankIndex = card_id % 13;
    let rank;
    switch (rankIndex) {
        case 0: rank = ranks.ace; break;
        case 1: rank = ranks.two; break;
        case 2: rank = ranks.three; break;
        case 3: rank = ranks.four; break;
        case 4: rank = ranks.five; break;
        case 5: rank = ranks.six; break;
        case 6: rank = ranks.seven; break;
        case 7: rank = ranks.eight; break;
        case 8: rank = ranks.nine; break;
        case 9: rank = ranks.ten; break;
        case 10: rank = ranks.jack; break;
        case 11: rank = ranks.queen; break;
        case 12: rank = ranks.king; break;
        default:
            logger.error('Invalid card ID rank', {
                code: ErrorCodes.INVALID_CARD_RANK,
                card_id,
                rankIndex,
                validRange: '0-12'
            });
            return undefined;
    }

    const matchingCards = deck.findCards((card) => card.rank === rank && card.suit === suit);
    if (!matchingCards || matchingCards.length === 0) {
        logger.error('Card not found in deck', {
            code: ErrorCodes.INVALID_CARD_SUIT,
            card_id,
            suit: suit.name,
            rank: rank.shortName
        });
        return undefined;
    }
    return matchingCards[0];
}

function get_cards_from_ids(ids, deck) {
    if (!Array.isArray(ids)) {
        logger.error('Invalid card IDs format', {
            code: ErrorCodes.INVALID_PLAYER_HAND,
            received: typeof ids,
            expected: 'array of numbers'
        });
        return [];
    }

    if (!deck) {
        logger.error('No deck provided', {
            code: ErrorCodes.INVALID_CARD_JOKER,
            idsCount: ids.length
        });
        return [];
    }

    const cards = [];
    ids.forEach((id, index) => {
        let numericId;
        try {
            numericId = parseInt(id, 10);
            if (isNaN(numericId)) {
                throw new Error('NaN');
            }
        } catch (error) {
            logger.error('Invalid card ID format', {
                code: ErrorCodes.INVALID_CARD_SUIT,
                index,
                id,
                error: error.message
            });
            return;
        }

        const card = get_card_from_id(numericId, deck);
        if (card) {
            cards.push(card);
        } else {
            logger.error('Invalid card ID', {
                code: ErrorCodes.INVALID_CARD_SUIT,
                index,
                id: numericId
            });
        }
    });
    return cards;
}

function get_card_points(card, withJoker) {
    try {
        if (!card || !card.rank || !card.rank.shortName) {
            logger.error('Invalid card object for points', {
                code: ErrorCodes.INVALID_CARD_RANK,
                card
            });
            return 0;
        }

        // Handle jokers
        if (card.rank.shortName === 'Joker') {
            return withJoker ? 25 : 0;
        }

        // Map face cards and Ace
        switch (card.rank.shortName) {
            case 'A': return 1;
            case 'J': return 11;
            case 'Q': return 12;
            case 'K': return 13;
            default:
                const points = parseInt(card.rank.shortName, 10);
                if (isNaN(points) || points < 2 || points > 10) {
                    logger.error('Invalid card rank for points', {
                        code: ErrorCodes.INVALID_CARD_RANK,
                        rank: card.rank.shortName,
                        validRanks: ['A', '2-10', 'J', 'Q', 'K']
                    });
                    return 0;
                }
                return points;
        }
    } catch (error) {
        logger.error('Error calculating card points', {
            code: ErrorCodes.INVALID_CARD_RANK,
            card,
            error: error.message
        });
        return 0;
    }
}

function check_play(cards, player) {
    if (!Array.isArray(cards)) {
        logger.error('Invalid cards array', {
            code: ErrorCodes.INVALID_PLAYER_HAND,
            received: typeof cards,
            expected: 'array of cards'
        });
        return false;
    }

    if (!player || !Array.isArray(player.hand)) {
        logger.error('Invalid player or hand', {
            code: ErrorCodes.INVALID_PLAYER_COUNT,
            player: player ? 'valid' : 'invalid',
            hand: player?.hand ? typeof player.hand : 'undefined'
        });
        return false;
    }

    if (cards.length < 1 || cards.length > player.hand.length) {
        logger.error('Invalid play: bad card number', {
            code: ErrorCodes.INVALID_PLAYER_HAND,
            cardsLength: cards.length,
            handLength: player.hand.length,
            validRange: `1-${player.hand.length}`
        });
        return false;
    }

    if (cards.length === 1) {
        logger.debug('Valid play: single card');
        return true;
    }

    const validatedCards = cards.every(card => {
        if (!card || !card.rank || !card.suit) {
            logger.error('Invalid card in play', {
                code: ErrorCodes.INVALID_CARD_SUIT,
                card
            });
            return false;
        }
        return true;
    });

    if (!validatedCards) {
        return false;
    }

    let sameRankCheck = true;
    let suitSequenceCheck = cards.length >= 3;
    let firstNonJoker = cards.find(card => card.rank.shortName !== 'Joker');
    
    if (!firstNonJoker) {
        logger.debug('Valid play: all jokers');
        return true;
    }

    let suit = firstNonJoker.suit;
    let rank = firstNonJoker.rank;

    if (!suit || !rank) {
        logger.error('Invalid non-joker card', {
            code: ErrorCodes.INVALID_CARD_SUIT,
            card: firstNonJoker
        });
        return false;
    }

    let jokerCount = cards.filter(card => card.rank.shortName === 'Joker').length;
    let normalCards = cards.filter(card => card.rank.shortName !== 'Joker');

    // Check same rank
    sameRankCheck = normalCards.every(card => {
        const isValid = card.rank.shortName === rank.shortName;
        if (!isValid) {
            logger.debug('Different rank found', {
                expected: rank.shortName,
                found: card.rank.shortName
            });
        }
        return isValid;
    });

    // Check suit sequence if not same rank and at least 3 cards
    if (suitSequenceCheck && !sameRankCheck) {
        let cardValues = normalCards
            .map(card => get_card_points(card, false))
            .sort((a, b) => a - b);

        // Check for invalid card points
        if (cardValues.includes(0)) {
            logger.error('Invalid card points in sequence', {
                code: ErrorCodes.INVALID_CARD_RANK,
                values: cardValues
            });
            return false;
        }

        let expectedValue = cardValues[0];
        let gapsToFill = 0;
        let maxGap = 0;

        for (let i = 1; i < cardValues.length; i++) {
            let diff = cardValues[i] - expectedValue - 1;
            if (diff > 0) {
                gapsToFill += diff;
                maxGap = Math.max(maxGap, diff);
            }
            expectedValue = cardValues[i];
        }

        // Check suit consistency
        const sameSuit = normalCards.every(card => {
            const isValid = card.suit.unicode === suit.unicode;
            if (!isValid) {
                logger.debug('Different suit in sequence', {
                    expected: suit.unicode,
                    found: card.suit.unicode
                });
            }
            return isValid;
        });

        suitSequenceCheck = sameSuit && gapsToFill <= jokerCount;

        if (!suitSequenceCheck) {
            logger.debug('Invalid sequence', {
                gapsToFill,
                jokerCount,
                maxGap,
                sameSuit
            });
        }
    }

    logger.debug('Play validation result', {
        sameRank: sameRankCheck,
        suitSequence: suitSequenceCheck,
        jokers: jokerCount,
        normalCards: normalCards.length
    });

    return sameRankCheck || suitSequenceCheck;
}

module.exports = {
    str_cards,
    print_players_hands,
    get_card_id,
    get_card_from_id,
    json_hand,
    get_cards_from_ids,
    get_card_points,
    check_play
};
